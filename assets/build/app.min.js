/**
 * @name Aroskanalen
 * @version v3.3.0
 * @link https://github.com/aroskanalen/screen
 */
/**
 * Defines the Angular Application.
 *
 * Dependency:
 *   A angularJS service to load dynamically CSS files. The original name of this
 *   project was angularDynamicStylesheets.
 */
angular.module('ikApp', [
    'ngAnimate',
    'angular.css.injector',

    'itkLog',

    'itkRegion',
    'itkDateComponent',
    'itkDigitalClockComponent',
    'itkKeypress'
  ]
).config(["$sceDelegateProvider", function ($sceDelegateProvider) {
    'use strict';

    // The administration interface and the client code do not run on the same
    // domain/sub-domain hence we need to white-list the domains to load slide
    // templates and CSS form the administration domain.
    $sceDelegateProvider.resourceUrlWhitelist([
      // Allow same origin resource loads.
      'self',
      // Allow loading from outer templates domain.
      '**'
    ]);
  }]).config(["$provide", function ($provide) {
    'use strict';

    $provide.decorator("$exceptionHandler", ['$delegate', '$injector',
      function ($delegate, $injector) {
        return function (exception, cause) {
          $delegate(exception, cause);

          // Send the error to itkLog.
          $injector.get('itkLog').error(exception, cause);
        };
      }
    ]);
  }]);

/**
 * @file
 * Contains the index controller.
 */

/**
 * Index Controller.
 *
 * Sets up the socket connection and displays the activation page if relevant.
 */
angular.module('ikApp').controller('IndexController', ['$scope', '$rootScope', '$timeout', 'socket', 'itkLog', 'cssInjector',
  function ($scope, $rootScope, $timeout, socket, itkLog, cssInjector) {
    'use strict';

    // Initial slide function array to hold custom slide plugins loaded from
    // the administration interface
    if (!window.hasOwnProperty('slideFunctions')) {
      window.slideFunctions = [];
    }

    // The template to render in the index.html's ng-include.
    $scope.template = 'app/pages/index/init.html?' + window.config.version;

    // Is the screen running (has the screen template been loaded?).
    $scope.running = false;

    // Default fallback image, used when no slide content exists. Default to
    // displaying it during load.
    $scope.fallbackImageUrl = window.config.fallback_image ? window.config.fallback_image : 'assets/images/fallback_default.png';
    $scope.displayFallbackImage = true;

    // Stored channels for when the screen template has not yet been loaded.
    // @TODO: jeskr: don't understand the comment?
    var savedChannelPushes = [];

    // Saved info about regions
    var regions = [];

    /**
     * Register to the regionInfo event.
     *
     * Updates whether or not the fallback image should be displayed.
     *
     * @TODO: jeskr: When is this event fired? What is it used for?
     */
    $rootScope.$on('regionInfo', function(event, info) {
      regions[info.id] = info;

      var dontDisplayDefaultImage = false;

      // Check if the region has any content.
      regions.forEach(function(region) {
        if (region.scheduledSlides > 0) {
          dontDisplayDefaultImage = true;
        }
      });

      $scope.displayFallbackImage = !dontDisplayDefaultImage;
    });

    /**
     * Register to the activationNotComplete event.
     *
     * @TODO: jeskr: When is this event fired? What is it used for?
     */
    $rootScope.$on('activationNotComplete', function() {
      $scope.$apply(function () {
        $scope.template = 'app/pages/notActivated/not-activated.html?' + window.config.version;
      });
    });

    /**
     * Register to the awaitingContent event.
     *
     * @TODO: jeskr: When is this event fired? What is it used for? Is it where
     *               used will default screen not be display while waiting on
     *               content?
     */
    $rootScope.$on('awaitingContent', function() {
      $scope.$apply(function () {
        $scope.template = 'app/pages/index/awaiting-content.html?' + window.config.version;
      });
    });

    /**
     * Register to the start event.
     *
     * Applies the screen template and emits stored channels to regions after a
     * 5 seconds delay.
     *
     * @TODO: jeskr: yes... 5 sec... why 5?
     */
    $rootScope.$on('start', function(event, screen) {
      if (!$scope.running) {
        // Load screen template and trigger angular digest to update the screen
        // with the template.
        $scope.$apply(function () {
          // Inject the screen stylesheet.
          cssInjector.add(screen.template.path_css);

          // Set the screen template.
          $scope.template = screen.template.path_live;
          $scope.templateDirectory = screen.template.path;

          $scope.options = screen.options;
        });

        // Wait 5 seconds for the screen template to load.
        // @TODO: jeskr: could the load process not return a promise, 5 sek is
        //               just an random number, why not wait 10?
        $timeout(function() {
          $scope.running = true;

          // Push all stored channels.
          for (var i = 0; i < savedChannelPushes.length; i++) {
            itkLog.info('Emitting channel saved channel.');
            $rootScope.$emit('addChannel', savedChannelPushes[i]);
          }
        }, 5000);
      }
    });

    /**
     * Register to the addChannel event.
     *
     * If the screen template is not running yet, store the channel for
     * emission after the screen template has been loaded.
     *
     * @TODO: Note about where this hidden emission happens? And if it's running
     *        why not emit it now?
     */
    $rootScope.$on('addChannel', function(event, data) {
      if (!$scope.running) {
        itkLog.info('Saving channel till screen is ready.');
        savedChannelPushes.push(data);
      }
    });

    /**
     * Logout and reload the screen.
     */
    $scope.logout = function logout() {
      // Use the socket to logout.
      socket.logout();
    };

    // Start the socket connection to the middleware.
    socket.start();
  }
]);

/**
 * @file
 * Contains the NotActivatedController.
 */

/**
 * NotActivatedController.
 *
 * Controllers the notActivated page.
 */
angular.module('ikApp').controller('NotActivatedController', ['$scope', 'socket',
  function ($scope, socket) {
    'use strict';

    $scope.activationCode = '';

    /**
     * Submit handler for the activation screen.
     */
    $scope.submitActivationCode = function() {
      socket.activateScreenAndConnect($scope.activationCode);
    };
  }
]);

/**
 * @file
 * Contains the activeEvents filter.
 *
 * A filter to display only events that have not yet bypassed their end date.
 *
 *
 * @TODO: jeskr: What are active events and it's related to calendar
 *               templates... should it not be load from the admin as
 *               template JS.
 */

/**
 * Add an active events filter to event list.
 *
 * @TODO: jeskr: The same date calculation is located in the schedule slide
 *               functions, this should be moved into a date utils extension.
 */
angular.module('ikApp').filter('activeEvents', function() {
  "use strict";

  return function(items) {
    // Return if event array empty.
    if (!angular.isArray(items)){
      return false;
    }

    // Get current time.
    var currentTime = parseInt(Date.now() / 1000);

    var ret = [];

    // Loop through event items.
    for (var i = 0; i < items.length; i++) {
      var item = items[i];

      // Calculate event duration.
      if (item.from && item.to && item.to >= currentTime) {
        ret.push(item);
      }
      else if (item.from && item.from >= currentTime) {
        ret.push(item);
      }
    }

    return ret;
  };
});
/**
 * @file
 * Contains the itkRegion module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app = angular.module("itkRegion", []);

  // Create ProgressBar object ot handle the bar.
  function ProgressBar(scope, itkLog) {
    this.scope = scope;
    this.itkLog = itkLog;
  }

  /**
   * Sets the progress bar style.
   *
   * @param duration
   *   How many seconds should the animation take?
   */
  ProgressBar.prototype.start = function start(duration) {
    this.scope.progressBarStyle =  {
      "overflow": "hidden",
      "-webkit-transition": "width " + duration + "s linear",
      "-moz-transition": "width " + duration + "s linear",
      "-o-transition": "width " + duration + "s linear",
      "transition": "width " + duration + "s linear",
      "width": "100%"
    };
  };

  /**
   * Reset the progress box.
   *
   * @return int
   *   The number of slides currently scheduled.
   */
  ProgressBar.prototype.resetBox = function resetBox() {
    var self = this;

    self.itkLog.info('resetProgressBox');
    self.scope.progressBoxElements = 0;
    self.scope.progressBoxElementsIndex = 0;

    var numberOfScheduledSlides = 0;

    for (var i = 0; i < self.scope.channelKeys[self.scope.displayIndex].length; i++) {
      var channelKey = self.scope.channelKeys[self.scope.displayIndex][i];
      var channel = self.scope.channels[self.scope.displayIndex][channelKey];

      if (channel.isScheduled) {
        for (var j = 0; j < channel.slides.length; j++) {
          var slide = channel.slides[j];
          if (slide.isScheduled) {
            numberOfScheduledSlides++;
          }
        }
      }
    }

    self.scope.progressBoxElements = numberOfScheduledSlides;

    return numberOfScheduledSlides;
  };

  /**
   * Set the next slide number in the info box.
   */
  ProgressBar.prototype.next = function next() {
    // Reset the bar.
    this.reset();

    // Update the counter.
    this.scope.progressBoxElementsIndex++;
  };

  /**
   * Resets the progress bar style.
   */
  ProgressBar.prototype.reset = function reset() {
    this.scope.progressBarStyle = {
      "width": "0"
    };
  };


  // Create region function object and use prototype to extend it to optimize
  // memory usage inside the region directive.
  function Region(scope, itkLog, progressBar, $timeout, $rootScope, $http, $interval, $sce) {
    this.scope = scope;
    this.itkLog = itkLog;
    this.progressBar = progressBar;
    this.$timeout = $timeout;
    this.$rootScope = $rootScope;

    this.$http = $http;
    this.$interval = $interval;
    this.$sce = $sce;

    // @TODO: Hardcode fade timeout?
    this.fadeTime = 1000;

    // @TODO: what is a channel key?
    this.channelKey = -1;

    // @TODO: try to get out of this timeout h...!
    this.timeout = null;
  }

  /**
   * Broadcast regionInfo event.
   *
   * @param slideCount
   *   The number of slides that are scheduled.
   */
  Region.prototype.broadcastInfo = function broadcastInfo(slideCount) {
    var self = this;
    self.$rootScope.$broadcast('regionInfo', {
      "id": self.scope.regionId,
      "scheduledSlides": slideCount
    });
  };

  /**
   * Calculated if the slide should be shown now.
   *
   * Stores the result of calculation on the slide object in the property
   * "isScheduled".
   *
   * @param slide
   */
  Region.prototype.isSlideScheduled = function isSlideScheduled(slide) {
    var now = Math.round((new Date()).getTime() / 1000);
    var from = slide.schedule_from;
    var to = slide.schedule_to;

    var fromSet = from && from !== 0;
    var toSet = to && to !== 0;

    if (fromSet && !toSet) {
      slide.isScheduled = from < now;
    }
    else if (fromSet && toSet) {
      slide.isScheduled = from < to && from < now && to > now;
    }
    else if (!fromSet && toSet) {
      slide.isScheduled = to > now;
    }
    else {
      slide.isScheduled = true;
    }
  };

  /**
   * Is the channel scheduled to be shown now?
   *
   * @param channel
   *   The channel to evaluate.
   * @returns {boolean}
   */
  Region.prototype.isChannelScheduled = function isChannelScheduled(channel) {
    // If no schedule repeat is set, it should be shown all the time.
    if (!channel.schedule_repeat)Â {
      return true;
    }

    var now = new Date();
    var nowDay = now.getDay();
    var nowHour = now.getHours();

    var hourFrom = channel.schedule_repeat_from;
    var hourTo = channel.schedule_repeat_to;
    var days = channel.schedule_repeat_days;

    // If all 3 parameters are not set return.
    if (!hourFrom && !hourTo && days.length === 0) {
      return true;
    }

    // Should it be shown today?
    var repeatToday = false;
    for (var i = 0; i < days.length; i++) {
      if (days[i].id === nowDay) {
        repeatToday = true;
        break;
      }
    }

    // Is it within scheduled hours?
    if (repeatToday) {
      if (hourFrom > hourTo) {
        return false;
      }

      return nowHour >= hourFrom && nowHour < hourTo;
    }

    return false;
  };

  /**
   * Is the channel published to be shown now?
   *
   * @param channel
   *   The channel to evaluate.
   */
  Region.prototype.isChannelPublished = function isChannelPublished(channel) {
    var now = Math.round((new Date()).getTime() / 1000);
    var publishFrom = channel.publish_from;
    var publishTo = channel.publish_to;

    channel.isScheduled = false;
    if (this.isChannelScheduled(channel)) {
      if (!publishFrom && !publishTo) {
        channel.isScheduled = true;
      }
      else if (publishFrom && now > publishFrom && (!publishTo || now < publishTo)) {
        channel.isScheduled = true;
      }
      else {
        channel.isScheduled = !publishFrom && now < publishTo;
      }
    }
  };

  /**
   * Update which channels are scheduled to be shown.
   */
  Region.prototype.updateScheduling = function updateScheduling() {
    var self = this;
    var displayIndex = self.scope.displayIndex;

    self.scope.channelKeys[displayIndex].forEach(function (channelKey, index, array) {
      var channel = self.scope.channels[displayIndex][channelKey];
      self.isChannelPublished(channel);

      channel.slides.forEach(function (slide) {
        self.isSlideScheduled(slide);
      });
    });
  };

  /**
   * Check if there are any slides that are scheduled.
   */
  Region.prototype.slidesRemainToBeShown = function slidesRemainToBeShown() {
    var self = this;
    var element;

    var displayIndex = self.scope.displayIndex;
    var len = self.scope.channelKeys[self.scope.displayIndex].length;

    // Check all channels to see if there are slides to show.
    for (var i = 0; i < len; i++) {
      var channel = self.scope.channels[displayIndex][self.scope.channelKeys[displayIndex][i]];

      if (channel.isScheduled) {
        // Check if there are any slides scheduled in the current channel.
        for (var k = 0; k < channel.slides.length; k++) {
          element = channel.slides[k];

          // @TODO: function is called slide(s), so why return true at first
          //        found slide?
          if (element.isScheduled) {
            return true;
          }
        }
      }
    }

    return false;
  };

  /**
   * Restart the show.
   *
   * Restart the show from the start of the current channels array,
   *   or if there have been changes, go to the other channels array.
   */
  Region.prototype.restartShow = function restartShow() {
    var self = this;

    self.itkLog.info("Restart show");

    // @TODO: The magic of -1 one values?
    self.scope.slideIndex = -1;
    self.channelKey = -1;

    // Swap to updated channel array, if there have been changes to channels.
    if (self.scope.slidesUpdated) {
      // @TODO: Would be nice with comment about this mod magic?
      var otherDisplayIndex = (self.scope.displayIndex + 1) % 2;

      var displayIndex = self.scope.displayIndex;
      var channels = self.scope.channels;
      channels[displayIndex] = angular.copy(channels[otherDisplayIndex]);
      self.scope.channelKeys[displayIndex] = Object.keys(channels[displayIndex]);

      // Update the display index to the new index value.
      self.scope.displayIndex = otherDisplayIndex;

      // Reset update variable as slides have been updated.
      self.scope.slidesUpdated = false;

      // @TODO: Remove the old data in channels[otherDisplayIndex] to free
      //        memory?
    }

    // Mark channels and slides that should not be show right now as they may be
    // scheduled for later. So set isScheduled = false for the slides.
    self.updateScheduling();

    // Reset progress box.
    self.broadcastInfo(self.progressBar.resetBox());

    // If no slides are to be displayed, wait 5 seconds and restart.
    if (!self.slidesRemainToBeShown()) {
      self.$timeout.cancel(self.timeout);
      self.timeout = self.$timeout(self.restartShow, 5000);
    }
    else {
      // Show next slide. @TODO: or is it next channel?
      self.nextChannel();
    }
  };

  /**
   * Go to next channel
   *
   * Switch to the next channel or cycle to the first. S
   */
  Region.prototype.nextChannel = function nextChannel() {
    var self = this;

    // @TODO: Add info about the channel to the log? The message said nothing.
    self.itkLog.info("Next channel");

    self.channelKey++;

    // If more channels remain to be shown, go to next channel.
    var displayIndex = self.scope.displayIndex;
    var channelKeys = self.scope.channelKeys;
    if (self.channelKey < channelKeys[displayIndex].length) {
      var nextChannelIndex = channelKeys[displayIndex][self.channelKey];
      var nextChannel = self.scope.channels[displayIndex][nextChannelIndex];

      if (nextChannel.isScheduled) {
        self.scope.channelIndex = nextChannelIndex;
        self.scope.slideIndex = -1;

        self.nextSlide();
      }
      else {
        self.$timeout.cancel(self.timeout);

        // @TODO: Why the timeout and why 100ms? Is it fast or is it slow? It's
        //       "flash"...
        self.$timeout(nextChannel, 100);
      }
    }
    else {
      self.restartShow();
    }
  };

  /**
   * Set the next slide, and call displaySlide.
   */
  Region.prototype.nextSlide = function nextSlide() {
    var self = this;
    
    // @TODO: Please add information about what the next slide is.
    self.itkLog.info("Next slide");

    var nextSlideIndex = self.scope.slideIndex + 1;

    var displayIndex = self.scope.displayIndex;
    var channels = self.scope.channels;
    var channelIndex = self.scope.channelIndex;

    // If overlapping current channel.slides length
    if (!channels[displayIndex][channelIndex] || nextSlideIndex >= channels[displayIndex][channelIndex].slides.length) {
      // @TODO: But wait... nextChannel calls nextSlide? Is this safe?
      self.nextChannel();
      return;
    }

    // If slides array is empty, wait 5 seconds, try again.
    if (channels[displayIndex][channelIndex] === undefined || channels[displayIndex][channelIndex].slides.length <= 0) {
      self.$timeout.cancel(self.timeout);

      // @TODO: Why the timeout of 5 sek?
      self.timeout = self.$timeout(self.nextSlide, 5000);
    }
    else {
      // Get current slide.
      self.scope.slideIndex = nextSlideIndex;
      var currentSlide = channels[displayIndex][channelIndex].slides[displayIndex];

      // If slide is not scheduled,
      //   make sure a slide is scheduled, to be shown, then go to next slide.
      //   else wait 5 seconds and then go to next slide.
      // This is to avoid fast loop over slides that are not scheduled,
      //   when no slide are scheduled.
      if (!currentSlide.isScheduled) {
        if (self.slidesRemainToBeShown()) {
          // @TODO: More information on slide missing?
          self.itkLog.info('Slide schedule: slides remain.');
          self.nextSlide();
        }
        else {
          self.itkLog.info('Slide schedule: slides do not remain');

          // If no slide scheduled, wait 5 seconds, then restart show.
          self.$timeout.cancel(self.timeout);
          // @TODO: Why is this not assigned "timeout" as all the others? And why 5 sek?
          self.$timeout(function () {
            self.restartShow();
          }, 5000);
        }
      }
      // If the slide is scheduled, show it.
      else {
        self.displaySlide();
      }
    }
  };

  /**
   * Update which slides to show next.
   *
   * @param data
   *   @TODO: what is data?
   */
  Region.prototype.updateSlideShow = function updateSlideShow(data) {
    var self = this;
    // @TODO: Would be nice with comment about this mod magic? It is also found
    //        in resetShow()
    var otherDisplayIndex = (self.scope.displayIndex + 1) % 2;
    var id = "" + data.id;

    self.scope.channels[otherDisplayIndex][id] = angular.copy(data);
    self.scope.channelKeys[otherDisplayIndex] = Object.keys(self.scope.channels[otherDisplayIndex]);
    self.scope.slidesUpdated = true;
  };

  /**
   * Display the current slide.
   */
  Region.prototype.displaySlide = function displaySlide() {
    var self = this;

    // To be sure to be sure that the timeout is completed from the last slide.
    // @TODO:
    self.$timeout.cancel(self.timeout);

    // Reset the UI elements (Slide counter display x/y and progress bar).
    self.progressBar.next();

    var slide = self.scope.channels[self.scope.displayIndex][self.scope.channelIndex].slides[self.scope.slideIndex];
    if (slide === undefined) {
      self.itkLog.info('No slides yet... waiting 5 seconds');

      // Wait five seconds and try again.
      // @TODO: The magic 5 sek once more and why it this not assigned "timeout"
      //        variable?
      self.$timeout(function () {
       self.displaySlide();
      }, 5000);
      return;
    }

    // Call the run function for the given slide_type.
    window.slideFunctions[slide.js_script_id].run(slide, self.scope, self, self.$http, self.$timeout, self.$interval, self.$sce, self.itkLog, self.progressBar, self.fadeTime);
  };

  /**
   * Region directive.
   *
   * html parameters:
   *   region (integer): region id.
   *   show-progress (boolean): should the progress bar/box be displayed?
   */
  app.directive('region', ['$rootScope', '$timeout', '$interval', 'itkLog', '$http', '$sce',
    function ($rootScope, $timeout, $interval, itkLog, $http, $sce) {
      return {
        restrict: 'E',
        scope: {
          regionId: '=',
          showProgress: '=',
          scale: '='
        },
        link: function (scope) {
          // To get smooth transitions between slides, channels consist of two arrays, that are switched between.
          // The current array consist of the channels that are in the current rotation, and the other array
          //   contains future slides.
          scope.channels = [
            {},
            {}
          ];
          // Since channels are set by keys, we need arrays of the keys, that we can cycle between.
          scope.channelKeys = [
            [],
            []
          ];
          var channelKey = -1;

          scope.slideIndex = null;
          scope.channelIndex = null;
          scope.displayIndex = 0;

          // @TODO: Is these used in templates? If not why in scope.
          scope.running = false;
          scope.slidesUpdated = false;

          // Used by progress bar
          scope.progressBoxElements = 0;
          scope.progressBoxElementsIndex = 0;

          var progressBar = new ProgressBar(scope, itkLog);
          var region = new Region(scope, itkLog, progressBar, $timeout, $rootScope, $http, $interval, $sce);

          // @TODO: comment needed.
          region.broadcastInfo(0);

          // Event handler for 'addChannel' event.
          // Content has arrived from the middleware.
          $rootScope.$on('addChannel', function handleAddChannel(event, channel) {
            if (channel === null) {
              return;
            }

            // Check if channel should not be added to region.
            // If it should not be in region and is already,
            //   remove it from the region.
            if (channel.regions.indexOf(scope.regionId) === -1) {
              var otherDisplayIndex = (scope.displayIndex + 1) % 2;
              var id = "" + channel.data.id;

              if (scope.channels[otherDisplayIndex].hasOwnProperty(id)) {
                itkLog.info("Removing channel " + channel.data.id + " from region " + scope.regionId);

                delete scope.channels[otherDisplayIndex][id];
                scope.channelKeys[otherDisplayIndex] = Object.keys(scope.channels[otherDisplayIndex]);
                scope.slidesUpdated = true;
              }

              return;
            }

            itkLog.info("Adding channel " + channel.data.id + " to region " + scope.regionId);

            // The show is running simply update the slides.
            if (scope.running) {
              region.updateSlideShow(channel.data);
            }
            else {
              // The show was not running, so update the slides and start the show.
              scope.$apply(function () {
                scope.running = true;

                // Insert channel into both arrays.
                var id = "" + channel.data.id;
                scope.channels[0][id] = angular.copy(channel.data);
                scope.channels[1][id] = angular.copy(channel.data);

                // Update key arrays
                scope.channelKeys[0] = Object.keys(scope.channels[0]);
                scope.channelKeys[1] = Object.keys(scope.channels[1]);

                // Select first channel.
                channelKey = -1;

                // Make sure the slides have been loaded. Then start the show.
                // @TODO: Yet another magic timeout value?
                $timeout(function () {
                  scope.slideIndex = -1;
                  scope.running = true;

                  // Mark channels and slides that should not be show as isScheduled = false
                  region.updateScheduling();

                  // Reset progress box
                  region.broadcastInfo(progressBar.resetBox());

                  region.nextChannel();
                }, 1000);
              });
            }
          });

          // Event handler for 'removeChannel' event.
          // Remove the channel from the next display array.
          $rootScope.$on('removeChannel', function removeChannelEvent(event, channel) {
            // @TODO: Would be nice with comment about this mod magic? Use 2 other place as well.
            var otherDisplayIndex = (scope.displayIndex + 1) % 2;
            var id = "" + channel.id;

            // If the channel is in the array, remove it.
            if (scope.channels[otherDisplayIndex].hasOwnProperty(id)) {
              delete scope.channels[otherDisplayIndex][id];
              scope.channelKeys[otherDisplayIndex] = Object.keys(scope.channels[otherDisplayIndex]);
              scope.slidesUpdated = true;
            }
          });
        },
        templateUrl: 'app/shared/region/region.html?' + window.config.version
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the slide directive.
 */

/**
 * Directive to insert html for a slide.
 *
 * html parameters
 *   ik-slide (object): The slide to display.
 *   show (boolean): Should the slide be visible?
 *
 *   ---- used for creation unique slide-id ----
 *   array-id (integer): The which displayIndex does this slide belong to?
 *   channel-id (integer): What channel does the slide belong to?
 *   index (integer): Which index in the channel does that slide have?
 *   region (integer): Which region does the slide belong to?
 *   ---- used for creation unique slide-id ----
 */
angular.module('ikApp').directive('slide', ['cssInjector',
  function(cssInjector) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikSlide: '=',
        show: '=',
        arrayId: '=',
        channelId: '=',
        index: '=',
        regionId: '=',
        scale: '='
      },
      link: function(scope, element, attrs) {
        scope.ikSlide.uniqueId = null;

        // Observe for changes to ik-array-id attribute. Set unique id.
        attrs.$observe('regionId', function(val) {
          if (!val) {
            return;
          }

          // Generate unique id for ikSlide.
          scope.ikSlide.uniqueId = '' + scope.regionId + '-' + scope.arrayId + '-' + scope.channelId + '-' + scope.index;
        });

        // Observe for changes to the ikSlide attribute. Setup ikSlide when set.
        attrs.$observe('ikSlide', function(val) {
          if (!val) {
            return;
          }

          // Check if script have been loaded. If it has not, load the script
          // and run setup function.
          if (!window.slideFunctions[scope.ikSlide.js_script_id]) {
            $.getScript(scope.ikSlide.js_path, function () {
              // The loaded script set an object with setup() and run() methods
              // into the slideFunctions array. Hence we can call setup on the
              // object in the array here.
              window.slideFunctions[scope.ikSlide.js_script_id].setup(scope.ikSlide, scope);
            });
          }
          else {
            // Script have been load before, so just run setup.
            window.slideFunctions[scope.ikSlide.js_script_id].setup(scope.ikSlide, scope);
          }

          // Inject stylesheet.
          cssInjector.add(scope.ikSlide.css_path);
        });
      },
      template: '<div data-ng-include="ikSlide.template_path"></div>'
    };
  }
]);

/**
 * Web-socket factory using socket.io to communicate with the middleware.
 */
angular.module('ikApp').factory('socket', ['$rootScope', 'itkLog',
  function ($rootScope, itkLog) {
    'use strict';

    var factory = {};

    // Get the load configuration object.
    var config = window.config;

    // Communication with web-socket.
    var socket;

    // Global variable with token cookie.
    var token_cookie;

    // Keeps track of connections.
    var reconnection = false;

    /**
     * Cookie object.
     *
     * Used to handle the cookie(s), mainly used to store the connection JSON Web Token.
     */
    var Cookie = (function () {
      var Cookie = function (name) {
        var self = this;

        // Get token from the cookie.
        self.get = function get() {
          var regexp = new RegExp("(?:^" + name + "|\s*" + name + ")=(.*?)(?:;|$)", "g");
          var result = regexp.exec(document.cookie);

          return (result === null) ? undefined : result[1];
        };

        // Set token.
        self.set = function set(value, expire) {
          var cookie = name + '=' + escape(value) + ';';

          if (expire === undefined) {
            expire = 'Thu, 01 Jan 2018 00:00:00 GMT';
          }
          cookie += 'expires=' + expire + ';';

          cookie += 'path=/;';
          cookie += 'domain=' + document.domain + ';';

          // Check if cookie should be available only over https.
          if (config.cookie.secure === true) {
            cookie += ' secure';
          }

          document.cookie = cookie;
        };

        // Remove the cookie by expiring it.
        self.remove = function remove() {
          self.set('', 'Thu, 01 Jan 1970 00:00:00 GMT');
        };
      };

      return Cookie;
    })();

    /**
     * Check if a valid token exists.
     *
     * If a token is found a connection to the proxy is attempted. If token
     * not found the activation form is displayed.
     *
     * If the key url-parameter is set, use that for activation.
     */
    var activation = function activation() {
      // Check if token exists.
      token_cookie = new Cookie('indholdskanalen_token');

      var token = token_cookie.get();

      if (token === undefined) {
        $rootScope.$emit("activationNotComplete");
      }
      else {
        // If token exists, connect to the socket.
        connect(token);
      }
    };

    /**
     * Load the socket.io script from the proxy server.
     */
    var loadSocket = function loadSocket(callback) {
      var file = document.createElement('script');
      file.setAttribute('type', 'text/javascript');
      file.setAttribute('src', config.resource.server + config.resource.uri + '/socket.io/socket.io.js');
      file.onload = function () {
        if (typeof io === "undefined") {
          itkLog.error("Socket.io not loaded");

          document.getElementsByTagName("head")[0].removeChild(file);
          window.setTimeout(loadSocket(callback), 100);
        } else {
          callback();
        }
      };
      document.getElementsByTagName("head")[0].appendChild(file);
    };

    /**
     * Connect to the web-socket.
     *
     * @param token
     *   JWT authentication token from the activation request.
     */
    var connect = function connect(token) {
      // Get connected to the server.
      socket = io.connect(config.ws.server, {
        'query': 'token=' + token,
        'force new connection': true,
        'max reconnection attempts': Infinity,
        'forceNew': true,
        'reconnection': true,
        'reconnectionDelay': 1000,
        'reconnectionDelayMax' : 5000,
        'reconnectionAttempts': Infinity
      });

      // Handle connected event.
      socket.on('connect', function () {
        // Connection accepted, so lets store the token.
        token_cookie.set(token);

        itkLog.log("Connection to middleware");

        // If first time we connect change reconnection to true.
        if (!reconnection) {
          reconnection = true;
        }

        // Set ready state at the server, with app initialized if this is a reconnection.
        socket.emit('ready');
      });

      // Handled deletion of screen event.
      socket.on('booted', function (data) {
        // Remove cookie with token.
        token_cookie.remove();

        // Reload application.
        location.reload(true);
      });

      /**
       * @TODO: HANDLE CHANNEL REMOVED EVENT:
       */
      socket.on('channelRemoved', function (data) {
        // Display channel ID of channel to remove.
        $rootScope.$emit('removeChannel', data);
      });

      /**
       * @TODO: HANDLE ERROR EVENT:
       */
      socket.on('error', function (error) {
        itkLog.error(error);
      });

      socket.on('disconnect', function(){
        itkLog.info('disconnect');
      });

      socket.on('reconnect', function(){
        itkLog.info('reconnect');
      });

      socket.on('reconnect_attempt', function(){
        itkLog.info('reconnect_attempt');
      });

      socket.on('connect_error', function(){
        itkLog.error('connect_error');
      });

      socket.on('reconnect_error', function(){
        itkLog.error('reconnect_error');
      });

      socket.on('reconnect_failed', function(){
        itkLog.error('reconnect_failed');
      });

      // Ready event - if the server accepted the ready command.
      socket.on('ready', function (data) {
        $rootScope.$emit('start', data.screen);

        if (data.statusCode !== 200) {
          // Screen not found will reload application on dis-connection event.
          if (data.statusCode !== 404) {
            itkLog.error('Code: ' + data.statusCode + ' - Connection error');
          }
        }
        else {
          // Only switch to awaiting content on a first time connection.
          if (!reconnection) {
            $rootScope.$emit('awaitingContent', {});
          }
        }
      });

      // Reload - if the server accepted the pause command.
      socket.on('reload', function (data) {
        // Reload browser windows (by-pass-cache).
        location.reload(true);
      });

      // Channel pushed content.
      socket.on('channelPush', function (data) {
        $rootScope.$emit('addChannel', data);
      });

      // Get logout event and send it to the middleware.
      $rootScope.$on('logout', function () {
        socket.emit('logout');
      });
    };

    /********************************
     * Public methods
     ********************************/

    /**
     * Call this to start the socket connection.
     */
    factory.start = function start() {
      loadSocket(function () {
        return activation();
      });
    };

    /**
     * Logout of the system.
     */
    factory.logout = function logout() {
      // Send socket logout event.
      $rootScope.$emit('logout');

      // Remove cookie with token.
      token_cookie.remove();

      // Reload application.
      location.reload(true);
    };

    /**
     * Activate the screen and connect.
     * @param activationCode
     *   Activation code for the screen.
     */
    factory.activateScreenAndConnect = function activateScreenAndConnect(activationCode) {
      // Build ajax post request.
      var xhr = new XMLHttpRequest();
      xhr.open('POST', config.resource.server + config.resource.uri + '/screen/activate', true);
      xhr.setRequestHeader('Content-Type', 'application/json');

      xhr.onload = function (resp) {
        if (xhr.readyState === 4 && xhr.status === 200) {
          // Success.
          resp = JSON.parse(xhr.responseText);

          // Try to get connection to the proxy.
          connect(resp.token);
        }
        else if (xhr.readyState === 4 && xhr.status === 409) {
          resp = JSON.parse(xhr.responseText);
          var dialog = confirm(resp.message);
          if (dialog === true) {
            // Create AJAX call to kick screens.
            var kickXHR = new XMLHttpRequest();
            kickXHR.open('POST', config.resource.server + config.resource.uri + '/screen/kick', true);
            kickXHR.setRequestHeader('Content-Type', 'application/json');
            kickXHR.setRequestHeader('Authorization', 'Bearer ' + resp.token);

            // Screen should be kick now so try to re-activate.
            kickXHR.onload = function (resp) {
              activateScreenAndConnect(activationCode);
            };

            // Something went wrong.
            kickXHR.onerror = function (exception) {
              // There was a connection error of some sort
              $rootScope.$apply(function() {
                itkLog.error('Kick request failed.', exception);
              });
            };

            // Send the request.
            kickXHR.send(JSON.stringify({
              "token": resp.token
            }));
          }
        }
        else {
          // We reached our target server, but it returned an error
          $rootScope.$apply(function() {
            itkLog.error(xhr.responseText, xhr);
          });
        }
      };

      xhr.onerror = function (exception) {
        // There was a connection error of some sort
        $rootScope.$apply(function() {
          itkLog.error('Activation request failed.', exception);
        });
      };

      // Send the request.
      xhr.send(JSON.stringify({
        "activationCode": activationCode,
        "apikey": config.apikey
      }));
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the itkDateComponent module.
 *
 * @TODO: jeskr: why is this code here... what is it used for?
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDigitalClockComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('digitalClockComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/digital-clock/digital-clock.html?' + window.config.version,
        scope: {
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = Date.now();
          }, 1000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * KeyPresses is used to capture keyboard presses.
 *
 * It's used in the screen to capture keyboard shortcut for logout.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var modifierPressed = false;
  var app;
  app = angular.module("itkKeypress", []);

  app.directive('itkKeypress', function () {
    return function (scope, element, attrs) {
      element.bind("keydown keypress", function (event) {

        // Capture modifier.
        if (event.which === Number(attrs.modifier)) {
          modifierPressed = true;
          return;
        }

        // Check if modifier was pressed last.
        if(modifierPressed && event.which === Number(attrs.key)) {
          scope.$apply(function () {
            scope.$eval(attrs.itkKeypress);
          });

          // Prevent default action.
          event.preventDefault();
        }

        // Reset modifier.
        modifierPressed = false;
      });
    };
  });

}).call(this);

/**
 * @file
 * Contains the itkDateComponent module.
 *
 * @TODO: jeskr: why is this code here... what is it used for?
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDateComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('dateComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/date/date.html?' + window.config.version,
        scope: {
          theme: '@'
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = new Date();
          }, 60000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);
